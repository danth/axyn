from __future__ import annotations
from axyn.database import UserRecord, MessageRevisionRecord
from discord import ChannelType, MessageType, Message
from logging import getLogger
from sqlalchemy import select
from typing import TYPE_CHECKING


if TYPE_CHECKING:
    from axyn.client import AxynClient
    from axyn.database import MessageRecord
    from sqlalchemy.ext.asyncio import AsyncSession
    from typing import Optional


_logger = getLogger(__name__)


def is_direct(client: AxynClient, message: Message) -> bool:
    """Return whether the given message is directly talking to Axyn."""

    axyn = client.axyn()

    if message.channel.type == ChannelType.private:
        return True

    if axyn.mentioned_in(message):
        return True

    if message.reference is not None:
        if isinstance(message.reference.resolved, Message):
            if message.reference.resolved.author == axyn:
                return True

    if "axyn" in getattr(message.channel, "name", ""):
        return True

    return False


async def is_valid(session: AsyncSession, message: MessageRecord) -> bool:
    """
    Return whether the given message is worth processing.

    This excludes messages which have no content stored.
    """

    revisions = await session.scalar(
        select(MessageRevisionRecord)
        .where(MessageRevisionRecord.message_id == message.message_id)
    )

    if not revisions:
        _logger.debug(f"{message.message_id} is not valid because no revisions were saved")
        return False

    return True


async def is_valid_response(session: AsyncSession, message: MessageRecord) -> bool:
    """
    Return whether the given message is worth indexing as a response.

    This excludes the same things as ``is_valid``, and also excludes
    messages generated by bots.
    """

    author = await session.get_one(UserRecord, message.author_id)

    if not author.human:
        _logger.debug(f"{message.message_id} is not valid because its author is not human")
        return False

    return await is_valid(session, message)


async def is_valid_prompt(session: AsyncSession, current: MessageRecord, prompt: MessageRecord) -> bool:
    """
    Return whether the given message is worth indexing as a prompt for the
    given response.

    This excludes the same things as ``is_valid``, and also excludes cases
    where a user replies to themself.

    This does not do any checks on the response, which is assumed to
    already be valid.
    """

    if prompt.author_id == current.author_id:
        _logger.debug(f"{current.message_id} is not valid because {prompt.message_id} has the same author")
        return False

    if prompt.deleted_at is not None:
        # If the prompt was deleted before the response was created, we can't
        # be sure whether they are replying to this or the message before.
        if prompt.deleted_at < current.created_at:
            _logger.debug(f"{current.message_id} is not valid because {prompt.message_id} was deleted prior")
            return False

    return await is_valid(session, prompt)


def reason_not_to_reply(message: Message) -> Optional[str]:
    """If the given message shouldn't be replied to, return a reason why."""

    if (
        message.type != MessageType.default and
        message.type != MessageType.reply
    ):
        return "this is not a regular message"

    if len(message.content) == 0:
        return "this message has no text"

    if message.author.bot or message.author.system:
        return "this message is authored by a bot"

